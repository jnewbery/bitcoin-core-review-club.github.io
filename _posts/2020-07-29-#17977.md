---
layout: pr
date: 2020-07-29
title: "Implement BIP 340-342 validation - Implement Taproot signature hashing"
pr: 17977
authors: [sipa]
components: ["consensus"]
host: jnewbery
status: past
commit: ad51604f
---

This is the third Review Club meeting on the (work in progress) implementation
of BIP 340-342.  We've previously looked at:

- [O(1) OP_IF/NOTIF/ELSE/ENDIF script implementation / Abstract out script
  execution out of VerifyWitnessProgram()](./16902)
- [Initialize PrecomputedTransactionData in CheckInputScripts and Move
  single-sig checking EvalScript code to EvalChecksig](./18401)

Those preliminary changes have been merged into the master branch in separate PRs.

This week, we'll look at one commit from PR 17977 - _[Implement Taproot
signature
hashing](https://github.com/bitcoin-core-review-club/bitcoin/commit/41d08f5d77f52bec0e31bb081d85fff2d67d0467)_.

**Participants are encouraged to review [the notes from the session on
PR18401](./18401) in particular, since we'll be covering a lot of the same
topics this week.**

## Notes

- The _transaction digest_ that is used in signature creation and verification
  is calculated from different parts of the transaction. There are extensive
  notes covering this topic from [our session on
PR18401](https://bitcoincore.reviews/18401#pr-18401-initialize-precomputedtransactiondata-in-checkinputscripts).

- BIP 341 contains [the specification of the new signature validation
  rules](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#signature-validation-rules).

- The [Taproot BIP Review series](https://github.com/ajtowns/taproot-review/)
  covered this topic in [week
  4](https://github.com/ajtowns/taproot-review/blob/master/week-4.md#signature-details).
  [The meeting
  log](http://www.erisian.com.au/meetbot/taproot-bip-review/2019/taproot-bip-review.2019-11-26-19.01.log.html)
  from that review session has more details.

- This week, we'll review the implementation of the Taproot transaction hashing
  algorithm. We won't look at full signature validation. It may be useful to
  check out just up to the commit _Implement Taproot signature hashing (BIP 341)_.
  Specifically, we'll be looking at the `SignatureHashSchnorr()` function in
  `src/script/interpreter.cpp`.

- It's probably most instructive to compare the new `SignatureHashSchnorr()`
  function to the `SignatureHash()` function immediately below, which
  calculates the signature hash for segwit v0 and legacy transactions.

## Questions

1. `SignatureHashSchnorr()` is a templated function. Why?  What types `T` is
   the template function instantiated with? _Hint: look at how the existing
   `SignatureHash()` function is called._

2. `SignatureHashSchnorr()` is passed a `PrecomputedTransactionData*` argument.
   What data is stored in this structure? Why?

3. `SignatureHashSchnorr()` is passed a `hash_type` argument. How many valid
   hash types are there? The `hash_type` parameter is split into `output_type`
   and `input_type` here:

     ```
     // Hash type
     const uint8_t output_type = ...
     const uint8_t input_type = ...
     ```

     How many valid values are there for `output_type` and `input_type`?

4. Just like `SignatureHash()`, the new function creates a local `CHashWriter`
   object. `CHashWriter` is a stream-like object. Other objects can be
   serialized into it (using the `<<` operator), and at the end,
   `CHashWriter::GetHash()` is called to retrieve the digest.

     One difference from `SignatureHash()` is that the `CHashWriter` is
     copy-constructed from `HasherTapSighash`. How is _that_ object constructed, and
     what's the difference from a regular `CHashWriter` object?

5. If the `hash_type` does not have the `ANYONECANPAY` flag, certain parts of
   the transaction are added to the `CHashWriter`. What are those elements, and
   how is that different from `SignatureHash()`?

6. A `spend_type` byte is added the `CHashWriter`. What are the component parts
   of `spend_type`, and what do they indicate? _Hint: refer back to BIP 341 and
   BIP 342._

7. If the `hash_type` indicates `SIGHASH_SINGLE`, there's a check here:

     `if (in_pos >= tx_to.vout.size()) return false;`

     What is that testing, and why?

## Meeting Log

{% irc %}
17:00 < jnewbery> #startmeeting
17:00 < jnewbery> hi folks!
17:00 < willcl_ark> hi
17:00 < pinheadmz> ðŸ‘‹
17:00 < emzy> hi
17:00 < fjahr> hi
17:00 < jnewbery> welcome to bitcoin core PR review club :)
17:00 < gzhao408> hola
17:00 < michaelfolkson> hi
17:01 < nehan> hi
17:01 < jnewbery> today we're going to be looking at a commit from the taproot implementation PR
17:01 < jnewbery> notes/questions in the normal place: https://bitcoincore.reviews/17977.html
17:01 < troygiorshev> hi
17:01 < kanzure> hi
17:01 < jnewbery> normal reminder: there are no stupid questions. We're all here to learn, so please speak up if something isn't clear to you. You'll be helping others too!
17:01 < raking> hi
17:02 < felixweis> hi
17:02 < webby> hi
17:02 < jonatack> hi (afk -> sleep, will read tomorrow am)
17:02 < jnewbery> other reminder: you can ask questions at any time. You don't have to ask to ask. I'll guide the discussion with some prepared questions, but feel free to jump in at any point with your question
17:02 < jnewbery> ok, let's get started
17:02 < jnewbery> who had a chance to review the commit?
17:02 < fjahr> y
17:03 < jnewbery> (not necessarily the full PR, just the changes to signature hashing)
17:03 < pinheadmz> y
17:03 < willcl_ark> y
17:03 < michaelfolkson> y
17:03 < emzy> n
17:03 < troygiorshev> y/n
17:03 < nehan> n
17:03 < webby> n
17:03 < jnewbery> great!
17:03 < raking> n
17:03 < felixweis> y
17:03 < jnewbery> First question: SignatureHashSchnorr() is a templated function. Why? What types T is the template function instantiated with? Hint: look at how the existing SignatureHash() function is called.
17:04 < troygiorshev> CTransaction and CMutableTransaction, I think that's it
17:04 < pinheadmz> is it because the function can accept both mutabelTX and TX ?
17:04 < willcl_ark> so you don't have to copy MutableTransaction  into a Transaction each time?
17:04 < fjahr> Different transaction types for the spending transaction. Could be CTransaction or CMutableTransaction afaict
17:04 < jnewbery> troygiorshev pinheadmz willcl_ark fjahr: correct! We can call it with either a CTransaction or CMutableTransaction, just like SignatureHash()
17:05 < jnewbery> any questions about that? Is everyone happy with templates?
17:06 < jnewbery> I'll move on, but feel free to come back and ask about a previous question if it doesn't make sense to you
17:06 < jnewbery> next
17:06 < jnewbery> SignatureHashSchnorr() is passed a PrecomputedTransactionData* argument. What data is stored in this structure? Why?
17:06 < gzhao408> in what situations are we working with a CMutableTransaction? our own txns?
17:06 < pinheadmz> gzhao408 yeah, when the wallet (for ex) is constructing a tx
17:06 < jnewbery> great question gzhao408! Anyone know?
17:06 < willcl_ark> Depends on which BIP143 (Segwit v0) or BIP341 (taproot) features the tx uses.
17:06 < pinheadmz> you can add inputs and outputs and signatures to an MTX
17:06 < pinheadmz> but a TX is what comes out of a block for verification
17:07 < jnewbery> pinheadmz: how about transactions that aren't in a block?
17:07 < pinheadmz> mempool tx are also not mutable
17:07 < sipa> (for some historic context: the distinction between tx and mtx arose from wanting to cache the txid and later wtxid inside a tx)
17:07 < jnewbery> pinheadmz: yep
17:08 < jnewbery> thanks sipa!
17:08 < sipa> as a tx is immutable, it can be cached without ever needing to worry about inconsistency or locking or whatever
17:08 < sipa> it may also enable having different container structures for tx that are more efficient (e.g. no separate allocation for all the inputs, outputs, scripts, ...)
17:08 < michaelfolkson> The state switches from mutable to immutable on announcement? Should check code...
17:09 < sipa> michaelfolkson: there is no state; it's an entirely different class
17:09 < pinheadmz> michaelfolkson i thought the walletconverts to tx before broadcast
17:09 < jnewbery> willcl_ark: yes, what we cache depends on the transaction type. Can you expand?
17:09 < sipa> and yes, it's converted from mtx to tx after signing
17:09 < willcl_ark> BIP143 tx: hashPrevouts, hashSequence, hashOutputs
17:10 < willcl_ark> BIP341 tx: as BIP143 + spentAmounts + spentScripts
17:10 < theStack> hi
17:10 < gzhao408> thanks this is really helpful :)
17:11 < pinheadmz> willcl_ark and some are double-sha256 and some are single-sha256!
17:11 < gzhao408> why do we double-sha256 things?
17:11 < sipa> gzhao408: because that's what BIP143 prescribes :)
17:12 < jnewbery> willcl_ark: I think those are actually all cached for all witness transactions. It's just that m_spent_amounts_hash and m_spent_scripts_hash are only used if the tx is taproot
17:12 < sipa> if your question is why did BIP143's authors chose that option: it was aiming to change as little as possible compared to pre-segwit sighashing, iirc
17:12 < jnewbery> gzhao408: it's what satoshi would have wanted
17:12 < willcl_ark> jnewbery: ah ok :) that makes sense tbh
17:12 < sipa> jnewbery: the PR was just updated, it now computes only the necessaey things
17:13 < jnewbery> sipa: ah! I haven't looked at this week's changes
17:13 < troygiorshev> gzhao408: apparently maybe protection against length extention attacks (but don't take my word on that)
17:13 < willcl_ark> Ah i checked out the PR from bitcoin/bitcoin
17:13 < sipa> troygiorshev: length extension attacks are not relevant in this context
17:14 < troygiorshev> sipa: ok thx
17:14 < sipa> (they apply when you're using a hash as a MAC, which implies there is secret data)
17:14 < jnewbery> does anyone have questions about PrecomputedTransactionData or should we move on?
17:14 < sipa> however, that may be the (ill advised) reason why satoshi chose for double hashing
17:15 < jnewbery> oh wow. PrecomputedTransactionData::Init() has changed quite a lot
17:16 < jnewbery> this is what it looked like previously: ttps://github.com/bitcoin-core-review-club/bitcoin/commit/41d08f5d77f52bec0e31bb081d85fff2d67d0467#diff-be2905e2f5218ecdbe4e55637dac75f3R1312-R1331
17:16 < jnewbery> https://github.com/bitcoin-core-review-club/bitcoin/commit/41d08f5d77f52bec0e31bb081d85fff2d67d0467#diff-be2905e2f5218ecdbe4e55637dac75f3R1312-R1331
17:16 < jnewbery> Next question. SignatureHashSchnorr() is passed a hash_type argument. How many valid hash types are there?
17:17 < michaelfolkson> 4
17:17 < jnewbery> any advances on 4?
17:17 < willcl_ark> 5
17:17 < willcl_ark> and two masks
17:17 < pinheadmz> 7 total i think?
17:17 < willcl_ark> or is it 6 and one mask
17:17 < pinheadmz> well 6 + default 0x00
17:17 < willcl_ark> hmmm
17:17 < sipa> how many total combinations are there?
17:17 < willcl_ark> final answer: 7
17:17 < sipa> bingo
17:17 < michaelfolkson> Are we including default and masks in that?
17:18 < jnewbery> that's right!
17:18 < jnewbery> How many valid values are there for output_type and input_type?
17:18 < jnewbery> https://github.com/bitcoin-core-review-club/bitcoin/commit/41d08f5d77f52bec0e31bb081d85fff2d67d0467#diff-be2905e2f5218ecdbe4e55637dac75f3R1371-R1372
17:18 < willcl_ark> 2 output and 1 input?
17:19 < michaelfolkson> I don't know what the masks are doing. Can someone explain? :)
17:19 < raking> same
17:19 < willcl_ark> they're for a bitwise AND
17:19 < gzhao408> it's leftmost bit and 2 rightmost bits
17:19 < sipa> they extract information
17:19 < jnewbery> michaelfolkson: all will become clear shortly
17:19 < michaelfolkson> Ok I'll be patient
17:19 < jnewbery> willcl_ark: it can't be 1 for input, otherwise we wouldn't need a variable to store it :)
17:20 < jnewbery> any advances on 2 and 1?
17:20 < willcl_ark> jnewbery: oh, I see what I've done
17:21 < theStack> next try: 3 values for output, 2 values for input
17:21 < jnewbery> ok, the sighash type dictates what parts of the transaction we hash to go into the signature
17:21 < jnewbery> theStack: yes!
17:21 < willcl_ark> so input has 8? and output 7?
17:21 < willcl_ark> oh, no ok
17:22 < jnewbery> part of the sighash type indicates which parts of the transaction's outputs go into the signature hash
17:22 < jnewbery> that can take the values SIGHASH_ALL, SIGHASH_SINGLE and SIGHASH_NONE (3 different options)
17:22 < gzhao408> i read it as output = SIGHASH_ALL, SIGHHASH_SINGLE, or SIGHASH_NONE and input = SIGHASH_ANYONECANPAY or 0?
17:23 < jnewbery> the other part of the sighash indicates which parts of the transaction's inputs go into the signature hash
17:23 < sipa> gzhao408: correct
17:23 < jnewbery> that can take the values SIGHASH_ANYONECANPAY or not (2 different options)
17:24 < troygiorshev> isn't the check on line 1501 unneccesary?
17:24 < jnewbery> those can be combined in any way so we get 3*2 = 6 different possibilities
17:24 < jnewbery> so where does the 7th come from?
17:24 < pinheadmz> huh this is a much simper way to think about sighashing
17:24 < pinheadmz> i been trying to kinda memorize each type individually
17:25 < pinheadmz> jnewbery that 7th is the default - sighash all
17:25 < pinheadmz> if there is no sighash byte at the end of the sig
17:25 < willcl_ark> ok I see now
17:25 < sipa> pinheadmz: but 1 is sighash_all already
17:25 < sipa> how does 0 differ?
17:25 < pinheadmz> you can not actually add 0x00 literally, it woudl be invalid
17:25 < sipa> indeed
17:25 < pinheadmz> its the default value assigned internaly if not sighash byte is present
17:26 < pinheadmz> and in fact 0x00 is invalid if it is present
17:26 < sipa> 0 is the implicit sighash type when the byte is missing
17:26 < sipa> so why is it an implicit 0 and not an implicit 1?
17:26 < pinheadmz> "because thats what is says in bip341" :-)
17:26 < willcl_ark> heh
17:26 < fjahr> jnewbery: you mean have_annex?
17:27 < sipa> pinheadmz: technically correct is the only kind of correct
17:27 < sipa> ;)
17:27 < troygiorshev> sipa: because the mask is on the last two bits?
17:27 < jnewbery> fjahr: I don't understand what you mean
17:27 < troygiorshev> (no that's not it)
17:27 < pinheadmz> sipa i actually don tknow - thought sighash all was only, no byte added -> implict 0x00
17:27 < sipa> troygiorshev: both 0 and 1 result in the same value after masking (ALL for outputs, 0 for inputs)
17:28 < sipa> fjahr: that's something unrelated
17:28 < sipa> it's hashed as well, but elsewhere
17:28 < jnewbery> fjahr: oh, you mean the annex is the 7th option? No, that's unrelated here. We'll get to it in a bit
17:28 < fjahr> ok
17:29 < sipa> so 0 is different from 1, because we don't want people to be able to malleate a 64-byte sig into a 65-byte one
17:29 < sipa> if it was just an implicit 1, you'd be able to add or remove it without affecting the validity of the signatire
17:30 < theStack> ah, that makes sense
17:30 < jnewbery> great point sipa. Thanks!
17:30 < jnewbery> ok, next question
17:30 < jnewbery> Just like SignatureHash(), the new function creates a local CHashWriter object. CHashWriter is a stream-like object. Other objects can be serialized into it (using the << operator), and at the end, CHashWriter::GetHash() is called to retrieve the digest.
17:30 < jnewbery> One difference from SignatureHash() is that the CHashWriter is copy-constructed from HasherTapSighash. How is that object constructed, and whatâ€™s the difference from a regular CHashWriter object?
17:30 < pinheadmz> but adding 0x01 at the end of the sig is not valid right? if you want sighash all you just leave it as a 64 byte sig with no explciit type?
17:31 < jnewbery> Oh, I see that it's now called HASHER_TAPSIGHASH in the latest push
17:32 < willcl_ark> sipa: Can't you malleate it in the opposite direction then? from 65 bytes to 64 bytes
17:32 < sipa> pinheadmz: you can do either; have a 64-byte one with implicit sighash 0, or explicitly make a 65-byte sig with hashtype 1; their semantics are the same... but the signature will still differ because the hash commits to the actual hashtype value
17:32 < sipa> willcl_ark: no
17:32 < troygiorshev> jnewbery: it starts with the double tag
17:33 < jnewbery> troygiorshev: exactly
17:33 < jnewbery> ok, follow-up question: what are tagged hashes and why do we use them in taproot
17:34 < pinheadmz> jnewbery i think its to prevent hash collisions with hashing the same data for other purposes
17:34 < troygiorshev> which, if I'm reading 340 right, helps prevent a collision across different uses of the same hash function
17:34 < jnewbery> pinheadmz troygiorshev: precisely
17:35 < jnewbery> See the section on tagged hashes in https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#design for full motivation
17:35 < troygiorshev> gzhao408: a new meaning of "double SHA256" :D
17:35 < sipa> troygiorshev: so why HASHER_TAPSIGHASH and not just start by writing the double tag into the stream?
17:35 < pinheadmz> sipa to cache the prefix ?
17:36 < fjahr> It's 64 bytes which is the size of a block in sha256
17:36 < felixweis> midstate caching
17:36 < sipa> yup, exactly
17:36 < sipa> it's copying the midstate after hashing the tag, so it avoids redoing that for every sighash
17:37 < troygiorshev> and it's static const so we get some sort of speedup copy constructing it?
17:37 < jnewbery> pinheadmz fjahr felixweiss: great stuff. If anyone is confused by the words 'midstate' or 'block' in this context, look up the SHA256 or merkle-damgard hash construction wikipedia pages
17:38 < jnewbery> troygiorshev: I'm not sure if the static or const make a difference there. Can you explain?
17:39 < jnewbery> next question: If the hash_type does not have the ANYONECANPAY flag, certain parts of the transaction are added to the CHashWriter. What are those elements, and how is that different from SignatureHash()?
17:40 < willcl_ark> It adds prevouts_hash, spend_amounts_hash, spent_scripts_hash and sequences_hash to the cache if its not ANYONECANPAY
17:40 < pinheadmz> a hash of all the inputs' prevouts
17:41 < willcl_ark> but SignatureHash does `SHA256Uint256(GetPrevoutHash(txTo)`
17:42 < jnewbery> willcl_ark: yes! https://github.com/bitcoin-core-review-club/bitcoin/commit/41d08f5d77f52bec0e31bb081d85fff2d67d0467#diff-be2905e2f5218ecdbe4e55637dac75f3R1380-R1385
17:43 < pinheadmz> so weitness v0 sighashing only commits to the value of the input being signed?
17:43 < troygiorshev> jnewbery: hmm I may be wrong, need to explore it a bit further
17:43 < pinheadmz> but v1 sighash we commit to value of ALL inputs? (unless ANYONECANPAY)
17:43 < pinheadmz> this is related to the recent hardware wallet fee-attack that was published i think
17:44 < felixweis> thats what cache->m_spent_amounts_hash is about
17:44 < jnewbery> pinheadmz: exactly. Can you explain a bit more about the fee-attack?
17:45 < pinheadmz> ok sure, so currently you can trick a hardware wallet into signing two separate transactions each with two inputs (say a big value and a small value input) then, create a new TX with just the two high value inputs, making the input to the tx unexpectedly large. the output value doesnt change, so the wallet loses a big fee
17:46 < sipa> troygiorshev: static just makes the variable inaccessible outside the compilation unit, and const prevents code from accidentally modifying the cached value; neither changes performance, they just prevent things we don't want to happen
17:46 < michaelfolkson> Luke did a good explanation of it https://diyhpl.us/wiki/transcripts/la-bitdevs/2020-06-18-luke-dashjr-segwit-psbt-vulnerability/
17:46 < pinheadmz> although now that im trying to explain, it seems like sighash single must be used for the attack so the bip341 updated couldnt prevent that ?
17:46 < sipa> pinheadmz: it doesn't need sighash_single
17:47 < pinheadmz> ok (grokking)
17:47 < sipa> and yes, signing all inputs prevents it (in sighash_all)
17:47 < sipa> *signing all input amounts
17:47 < jnewbery> there's a good write-up of the segwit v0 sighash fee issue in the optech newsletter: https://bitcoinops.org/en/newsletters/2020/06/10/#fee-overpayment-attack-on-multi-input-segwit-transactions
17:48 < pinheadmz> oh the trick is lying about the value of an input being spent
17:48 < pinheadmz> which would normally make a tx invalid on the network
17:48 < jnewbery> it's been known about for some time, and adding a new segwit version allows us to resolve that class of issues by introducing a new sighash algorithm
17:48 < pinheadmz> but the attecker throws that input away for the final tx
17:48 < jnewbery> Next question: A spend_type byte is added the CHashWriter. What are the component parts of spend_type, and what do they indicate? Hint: refer back to BIP 341 and BIP 342.
17:49 < jnewbery> fjahr: you might be able to answer this one :)
17:49 < willcl_ark> Whether it's taproot or tapscript and with annex or not
17:49 < michaelfolkson> ext_flag and annex_present
17:49 < pinheadmz> script path vs key path
17:49 < pinheadmz> oh and a flag for has_annex
17:49 < jnewbery> willcl_ark michaelfolkson pinheadmz: exactly correct
17:50 < jnewbery> it's specified in https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#common-signature-message
17:50 < jnewbery> "spend_type (1): equal to (ext_flag * 2) + annex_present, where annex_present is 0 if no annex is present, or 1 otherwise (the original witness stack has two or more witness elements, and the first byte of the last element is 0x50)"
17:50 < jnewbery> Last question:
17:50 < jnewbery> If the hash_type indicates SIGHASH_SINGLE, thereâ€™s a check here:
17:50 < jnewbery> if (in_pos >= tx_to.vout.size()) return false;
17:50 < jnewbery> What is that testing, and why?
17:51 < pinheadmz> heh, the sighash single bug :-)
17:51 < jnewbery> pinheadmz: go on...
17:51 < felixweis> SIGHASH_SINGLE is a mode where for every input there is 1 output
17:51 < pinheadmz> if there is an input signed with sighash single but no corresponding output...
17:52 < pinheadmz> satoshis code returns an error code of 1
17:52 < pinheadmz> which gets interpreted as 32 byte hash value!
17:52 < pinheadmz> which means you can compute a signature and store in the output of the tx being spent
17:53 < pinheadmz> and this happened on mainnet and ive heard it refered to as "the coolese transaction ever"
17:53 < pinheadmz> and AFAIK, the only legit use for OP_CODESEPARATOR ?
17:53 < willcl_ark> good knowledge !
17:54 < pinheadmz> willcl_ark https://github.com/bcoin-org/bcoin/blob/master/test/tx-test.js#L260-L264
17:54 < jnewbery> hmmm I'm not sure about the part about OP_CODESEPARATOR. I know that people have tried to use that in protocols like tumblebit to allow different signing paths
17:54 < pinheadmz> ah ok, i was hoping to get correted on that
17:54 < sipa> pinheadmz: i vaguely recall that, but i don't remember the details
17:55 < jnewbery> There are some mailing list posts by roconnor about OP_CODESEPARATOR in the last few months if you're interested
17:55 < jeremyrubin> wait the tx's signature can be comitted to inside the output being spent?
17:55 < pinheadmz> sipa was it not possile to fix sighashsingle in witnessv0?
17:56 < pinheadmz> jeremyrubin yes in this case bc of sighash single bug. bc the data signed is 0x0000.....01
17:56 < jnewbery> There's a writeup of the sighash_single bug here: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-November/006878.html
17:56 < pinheadmz> (not an actual digest of the spending tx)
17:56 < sipa> pinheadmz: i think we just chose not to
17:56 < sipa> (i don't think it's really a bug a such, just a major footgun)
17:56 < pinheadmz> jnewbery is excellent at finding things quickly! i knew it was a peter todd post but couldnt find it
17:57 < sipa> pinheadmz: if you run into it, you're already doing something wrong
17:57 < jnewbery> the idea behind SIGHASH_SINGLE is that only the output with the corresponding index to the input being spent is included in the hash. Obviously for that to work, there needs to be an output with the same index as the input being signed
17:57 < jnewbery> that's what the check is for
17:58 < jnewbery> ok, 3 minutes left. Any final questions?
17:58 < instagibbs> https://github.com/UnderhandedCrypto/entries/blob/master/2016/JonasNick/README-JUDGES.txt nickler did a contest submission based on the weirdness
17:58 < jnewbery> s/3/2/
17:59 < michaelfolkson> Wen moar Taproot
17:59 < willcl_ark> instagibbs: and a good writeup of the bug too
17:59 < willcl_ark> that's cleared it right up
18:00 < jnewbery> michaelfolkson: we'll do more taproot soon. Next week is multiprocess though, hosted by ryanofsky. You won't want to miss it!
18:00 < jnewbery> ok, times up. Thanks all. Great session
18:00 < jnewbery> #endmeeting
{% endirc %}
